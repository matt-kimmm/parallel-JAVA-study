# 01 개요

  여러 작업을 동시에 실행하는 프로그램을 제대로 돌아가게 작성하기는 어렵다. 어려운 데 왜 동시에 돌려야할까? 스레드는 자바 언어에서 피할 수 없는 특성이고, 복잡한 비동기 코드를 더 단순한 순차적 코드로 바꿔 복잡한 시스템을 단순하게 개발할 수 있게 해주기 때문이다. 게다가 스레드는 멀티프로세서 시스템의 능력을 최대한 끌어낼 수 있는 가장 쉬운 방법이다. 



## 1.1 작업을 동시에 실행하는 일에 대한 간략한 역사

초기에는 컴퓨터에 운영체제 자체가 없었다. 컴퓨터는 하나의 프로그램을 처음부터 끝가지 실행하기만 했고, 해당 프로램은 모든 자원을 직접 접근할 수 있었다. 이러한 프로그램은 작성하기 힘들었을 뿐 아니라 한 번에 프로그램 하나만을 위해 그 비싼 컴퓨터 자원을 드문 드문 사용하기 때문에 자원 대비 성능은 상당히 비효율적이었다.

운영체제는 여러 개의 프로그램을 각자의 프로세스 내에서 동시에 실행할 수 있도록 발전됐다. 이렇게 발전된 요인을 뽑자면 다음과 같다. 

- 자원 활용

  : 프로그램은 때로 입출력 같이 외부 동작이 끝나기를 기다려야하는 경우가 많은데 기다리는 동안은 유용한 일을 처리하지 못한다. 따라서 하나의 프로그램이 기다리는 동안 다른 프로그램을 실행하도록 지원하는 편이 더 효율적이다.

- 공정성

  : 여러 사용자와 프로그램이 컴퓨터 내 자원에 대해 동일한 권한을 가질 수 있는데, 한 프로그램이 종료된 후에야 다른 프로그램을 실행하는 것보다는 더 작은 단위로 컴퓨터를 공유하는게 바람직하다.

- 편의성

  : 여러 작업을 전부 처리하는 프로그램보다는 각기 일을 처리하는 프로그램을 만드는게 더 편리할 때가 있다. 

스레드는 마치 우리가 커피 포트에 물을 끓이는 동시에 토스트를 준비하거나 신문을 가져오는 것처럼 한 프로세스 안에 여러 개의 프로그램 제어 흐름을 공존시키고자 만들어졌다. 

스레드는 메모리, 파일 핸들과 같이 프로세스에 할당된 자원을 공유한다. 하지만 각 스레드는 각기 별도의 프로그램 카운터, 스택, 지역 변수를 갖는다. 의도적으로 조율하지 않는 한 하나의 스레드는 다른 스레드와 상관 없이 비동기적으로 실행된다. 또한 자신이 포함된 메모리 주소 공간을 공유하기 때문에 한 프로세스 내 모든 스레드는 같은 변수에 접근하고 같은 힙에 객체를 할당한다. 이를 통해 프로세스 때보다 더 세밀한 단위로 데이터를 공유할 수 있다. 하지만 데이터 접근 과정을 적절히 동기화하지 않으면 다른 스레드가 사용 중인 변수를 순간적으로 수정해서 예상치 못한 결과를 얻을 수 있다.



## 1.2 스레드의 이점

### 멀티 프로세서

이제는 많은 프로세서를 탑재한 컴퓨터가 기본이다. 프로세서 스케줄링의 기본 단위는 스레드이기 때문에 스레드 하나로 동작하는 프로그램은 한 번에 최대 하나의 프로세서만 사용한다. 프로세서가 두 개인 시스템에서 스레드가 하나 뿐인 프로그램은 CPU 자원의 50%를 낭비하는 꼴이다. 

뿐만 아니라 여러 개의 스레드를 사용하면 프로세서가 하나라 해도 처리 속도를 높일 수 있다. 멀티스레드 프로그램은 스레드 하나가 I/O가 끝나길 기다리는 동안 다른 스레드가 계속 실행될 수 있다.



### 단순한 모델링

여러 일을 한번에 처리하는 프로그램은 해당 프로그램에 대해 복잡성을 증가시킨다. 스케줄링, 비동기 I/O, 요청 관리 등등 을 각기 스레드에 맡기면 각 스레드가 처리하는 프로그램 개발의 작업이 훨씬 단순해진다.



### 단순한 비동기 이벤트 처리

여러 클라이언트 프로그램에서 소켓 연결을 받는 서버 애플리케이션은 각 연결마다 스레드를 할당하고 동기 I/O를 사용하도록 하면 개발 작업이 쉬워진다. 읽을 데이터가 없을 때 소켓에서 읽으려고 하면 어플리케이션은 read 연산에서 대기한다. 스레드가 하나라면 무한대기를하며 다른 작업도 처리하지 못하게 된다. 이럴 때는 더 복잡하고 실수하기 쉬운 ***논블록킹 I/O***를 써야한다. 하지만 각 요청을 스레드에 할당하면 대기 상태에 들어가도 다른 스레드가 요청을 처리하는데는 별 영향을 끼치지 않는다. 

> Q. 동기 vs 비동기 vs 블록킹 vs 논블록킹



### 더 빨리 반응하는 사용자 인터페이스

과거 GUI 애플리케이션은 하나의 스레드로 동작해, 사용자 입력을 계속 접검하거나 메인 이벤트 루프를 통해 애플리케이션 코드를 간접적으로 실행했다. 만약 호출한 코드가 너무 오래 실행되면 UI가 멈춘 것처럼 보이기도 했다. 이러한 작업을 별도의 스레드에 위임하면 UI는 항상 빠르게 반응할 것이다.



## 1.3 스레드 사용의 위험성

*개발자라면 대부분 스레드 안전성에 대해 잘 알아야한다.*



### 데이터 안정성

스레드 안전성은 생각보다 미묘하다. 동기화를 충분히 하지 않으면 여러 스레드에서 실행되는 연산의 순서가 때론 놀라울 만큼 예측하기 어렵다. 

```java
@NotThreadSafe
public class UnsafeSequence {
  private int value;
  
  /** 유일한 값을 리턴 */
  public int getNext() {
    return value++;
  }
}
```

위의 코드는 타이밍이 좋지 않은 시점에 두 스레드가 `getNext` 메소드를 동시 호출했을 때 같은 값을 얻을 가능성이있다. 

```
A(value -> 9) -> A(9 + 1 -> 10) -> A(value=10)
    B(value -> 9) -> B(9 + 1 -> 10) -> B(value=10)
```

이러한 점은 이후 장에서 다뤄보도록 하겠다.



### 활성(liveness)

멀티스레드 프로그램은 단일 스레드의 무한 반복문과 같은 것처럼 추가적 문제가 발생한다. 예를 들어 A 스레드에서 B 스레드가 독점하고 있는 자원을 기다리는 데 B가 이를 놓지 않은면 A는 영영 기다리게된다. 추후 10장에서 데드락(deadlock), 소모상태(starvation), 라이브락(livelock) 등 여러가지 활성 장애 유형을 소개한다.



### 성능

잘 설계된 병렬 프로그램은 궁극적으로 성능을 향상시킬 수 있다. 하지만 스레드를 사용하면 실행 중에 어느 정도 부하가 생기기는 한다. 스레드가 많은 프로그램은 컨텍스트 스위칭(다른 스레드가 실행될 수 있게 스케줄러가 현재 실행중인 스레드를 멈출 때)이 더 빈번하기 때문이다. 또한 스레드가 데이터를 공유하면 동기화 수단도 사용해야 한다. 이런 동기화는 컴파일러 최적화를 방해하고 메모리 캐시를 지우거나 무효화하기도 한다. 



## 질문

1. 논블록킹
2. 메모리 캐시 무효화 관련해서 이해가 잘 안된다.