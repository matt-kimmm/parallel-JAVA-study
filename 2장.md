## 2장 스레드 안전성

### 스레드안전성이란?

- 공유되고 변경할 수 있는 상태에 대한 접근을 관리하는 것

- 데이터에 제어 없이 동시에 접근하는 걸 막으려는 것

- 동기화가 제대로 되지 않으면 데이터 손상 가능성 있음

- #### 여러 스레드가 클래스에 접근 할 때 실행 환경이 해당 스레드들의 실행을 어떻게 스케줄 하든 어디에 끼워넣든 호출하는 쪽에서 추가적인 동기화나 다른 조율 없이도 정확하게 동작하는경우 해당 클래스는 스레드에 안전하다 라고 말할 수 있다.

  

### 동기화가 되지 않는 하나의 상태변수가 있는경우 해결방법

- 해당 상태 변수를 스레드간에 공유하지 않기
- 해당 상태 변수를 변경할 수 없도록 만들기
- 해당 상태 변수에 접근 시 항상 동기화를 사용하기



~~~java
@ThreadSafe
public class StatelessFactorizer implements Servlet {
  public void service(ServletRequest req, ServletResponse resp) {
    BigInteger i = extractFromRequest(req);
    BigInteger[] factors = factor(i);
    encodeIntoResponse(resp, factors);
  }
}
~~~

위 코드에서 특정 계산을 위한 상태는 스레드의 스택에 저장되는 지역변수에만 저장이된다.

StatelessFactorizer 에 접근하는 스레드는 해당 클래스를 접근하는 다른 스레드의 결과에 영향을 주지 않는다.

그러므로 위 코드는 스레드 안전하다고 할 수 있다.

(위 클래스는 선언한 변수가 없고, 다른 클래스의 변수를 참조하지도 않는다. - 이를 상태가 없는 객체라고 함)



~~~java
@NotThreadSafe
public class UnsafeCountingFactorizer implements Servlet {
  private long count = 0;
  public long getCount() { return count; }
  public void service(ServletRequest req, ServletResponse resp) {
    BigInteger i = extractFromRequest(req);
    BigInteger[] factors = factor(i);
    ++count;
    encodeIntoResponse(resp, factors);
  }
}
~~~

count 라는 변수를 선언하고 요청 수를 기록하는 상태를 추가한 객체이다.

count++ 라는 연산은 한줄짜리 코드이지만 결국 아래와 같은 동작을 하게된다

(count 변수를 읽어들임, 1을 더함, 새값을 count에 저장함)

이는, 두개 이상의 스레드가 해당 클래스를 접근할경우 순서에 따라 count값을 동시에 두번 읽고, 값을 증가시킴에 따라 최종값이 적용되지 않을 수 있다.



### 경쟁조건

- jvm이 여러 스레드를 교차해서 실행하는 상황에 따라 계산의 정확성이 달라질경우
- 타이밍이 정확히 맞아 떨어질때만 올바른 결과값이 나올경우
- ex )  두 사람이 전화를 동시에 걸었을 경우 서로 통화중이라 연결이 불가능한 상태



~~~java
@NotThreadSafe
public class LazyInitRace {
  private ExpensiveObject instance = null;
  
  public ExpensiveObject getInstance() {
    if(instance == null)
      instance = new ExpensiveObject();
    return instance;
  }
}
~~~

위 코드도 ThreadSafe 하지 않다.

특정 두 스레드가 동시에 해당 객체에 접근 할 경우 경쟁조건 때문에 제대로 동작하지 않을 수 있다.

-> 서로다른 instance 객체가 각각의 쓰레드에서 생성될 수 있다



#### 스레드 안전하기 위해서는 연산의 단일성을 보장해야한다.

~~~java
@ThreadSafe
public class CountingFactorizer implements Servlet {
  private final AtomicLong count = new AtomicLong(0);
  public long getCount() { return count.get(); }
  public void service(ServletRequest req, ServletResponse resp) {
    BigInteger i = extractFromRequest(req);
    BigInteger[] factors = factor(i);
    count.incrementAndGet();
    encodeIntoResponse(resp, factors);
  }
}
~~~

위의 UnsafeCountingFactorizer 클래스를 단일연산으로 처리하기 위하여 변경한 코드이다.

java.util.concurrent.atomic 패키지는 숫자나 객체 참조값에 대해 상태를 단일연산으로 변경할 수 있는 단일연산변수 클래스가 있다.

count 값이 AtomicLong 으로 변경되었으므로 카운터가 증가할 때 모든 동작이 단일연산으로 처리된다.

- incrementAndGet() : +1 증가시키고 변경된 값 리턴



### 락(lock)





